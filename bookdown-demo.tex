% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
  \usepackage{amssymb}
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Microdata Onboarding},
  pdfauthor={CMD team},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{longtable,booktabs}
\usepackage{calc} % for calculating minipage widths
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage{booktabs}
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother
\ifluatex
  \usepackage{selnolig}  % disable illegal ligatures
\fi
\usepackage[]{natbib}
\bibliographystyle{apalike}

\title{Microdata Onboarding}
\author{CMD team}
\date{2021-01-24}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{prerequisites}{%
\chapter{Prerequisites}\label{prerequisites}}

Make sure that you have a signed contract. Even though some lessons are useful in general, it is best if you have full access to the microdata resources (e.g.~server, slack, github, etc.) first. To gain access to every resource, you need a CEU-issued e-mail address, which you should receive shortly after signing your contract.

\hypertarget{terminal}{%
\chapter{Terminal}\label{terminal}}

\hypertarget{the-command-line-interface}{%
\chapter{The Command Line Interface}\label{the-command-line-interface}}

You probably mostly use your computer via something called a GUI, or Graphical User Interface. Practically any modern operating system comes with a GUI. It is the GUI that, for example, allows you to instruct your computer to run applications by double clicking on an application's icon instead of issuing your commands in writing.

However, it is not the only way to use your computer. Before the quick rise in computing capacity and memory, graphical interfaces were impossible to develop. Originally computers are instructed via written commands in something called a CLI, or Command Line Interface. Practically anything that is feasible using a GUI can be done using the CLI, even though it might be much more difficult. Then why bother with using the CLI at all? - you might ask. There are two main reasons for familiarizing yourself with the CLI at MicroData:
1. The servers that we use have very limited graphical support, and you will mostly use an Ubuntu terminal when you work on the servers.
2. Most freshly developed tools for data analysis simply do not have a GUI. It takes a lot of resources to develop GUIs, and most open source developers focus their attention to the core performance of the tools instead of a GUI. If you want to use these, you have to familiarize yourself with the CLI of your computer.

\hypertarget{how-are-commands-interpreted}{%
\section{How are commands interpreted?}\label{how-are-commands-interpreted}}

Every operating system comes with a command line interface. The CLI, just like the GUI is, however, different on each operating system. Most modern Windows operating systems use a CLI called Windows PowerShell, while Unix-like systems like MacOS, Ubuntu and other Linux distributions usually use a CLI called Terminal.

It is not only the name of the CLI that differs. The commands that you issue in the CLI have to be interpreted by the computer (translated to a long list of ones and zeros) in order to execute your commands. The way that commands are translated also differs across operating systems. Without going into too much details, it practically depends on something called the command line interpreter, which is a software that does this translation for you. On Windows, this is called cmd.exe, while on most Unix-like systems it's called Bash. The main problem with having mulitple CLIs and command line interpreters is that they understand different commands and translate these commands differently. Something that works on Ubuntu will very likely not work on Windows and vice-versa.

However, as mentioned before, the command line interpreter is just a software. Some of these interpreters have versions available for many different operating systems. The most widely used interpreter is probably Bash. If you are using MacOS or Ubuntu, you are good to go, you already have Bash installed on your computer. If you work with Windows, then you have already installed Git-bash, which, as it's name suggests, is a Bash interpreter. You will have to use this instead of the default Windows CLI throughout this episode.

\hypertarget{the-terminal}{%
\section{The Terminal}\label{the-terminal}}

The CLI that we are going to use is called the Terminal (on Unix-like systems) or Git-bash (on Windows). From here on, they both will be referenced as the Terminal. If you open a Terminal window, you are supposed to see an almost-blank window with something like this written on it:
\textgreater{} \texttt{johndoe@haflinger:\textasciitilde{}\$}

It should be followed by a blinking cursor. This is called the command prompt. It tells you some important information about where you are currently working. It is structured the following way:
\textgreater{} \texttt{username@machine:current\_directory\$}

These are possibly the most important pieces of information that you need to be aware of when using the CLI. What do they tell you?
1. username: This is your username on your computer. In most cases it will not change. In many systems you can switch to a user called root, that can do anything on the computer that a standard user cannot. You should only see your username there, if it changes you should close the Terminal and start a new session unless you are really sure about what you are doing.
2. machine: This is separated from the username by an \texttt{@} sign in most cases. It will change for example if you log in to the server. You will be able to control the MicroData servers using the Terminal as well. It is important to know whether you are controlling your own computer or the server in the Terminal window, always make sure that you are working on the proper machine.
3. current\_directory: This is usually separated from the name of the machine by a colon. In many operating systems you have something called your home folder or user folder. It is usually referenced in the Terminal by the \texttt{\textasciitilde{}} sign. If you change the working directory (which will be discussed in a second), it will change accordingly. For example on an other machine and in a different folder it might be something like this:
\textgreater{} \texttt{johndoe@johndoe-DELL:\textasciitilde{}/Documents/onboarding/\_episodes}

In order to use your computer via the Terminal, you will have to type commands and press enter. They will be executed one-by-one. The rest of this episode will be about the most important commands in the Terminal.

\hypertarget{the-most-important-terminal-commands}{%
\chapter{The most important Terminal commands}\label{the-most-important-terminal-commands}}

Terminal commands can be executed by pressing enter after typing them. The general structure of a command is the following:
\texttt{command\ \textless{}positional\ arguments\textgreater{}\ \textless{}optional\ arguments\textgreater{}}. Some commands work by themselves, while others require arguments (for example if you want to change the working directory, you have to specify the new working directory). Positional arguments always have to be specified, while optional arguments are, as their name suggests, optional. You can almost always get a detailed explanation on the positional and optional arguments by opening up the manual of the command by executing \texttt{man\ \textless{}command\textgreater{}} or by calling the command with its help optional argument by \texttt{\textless{}command\textgreater{}\ -\/-help} or \texttt{help\ \textless{}command\textgreater{}}

You can find the most commonly used commands with a short description below by categories. If you prefer, you can check out \href{https://datacarpentry.org/shell-economics/}{this Carpentries page}, which contains a more detailed walkthrough for each command.

\hypertarget{navigation}{%
\section{Navigation}\label{navigation}}

\begin{itemize}
\item
  \texttt{pwd} returns the path to the current working directory. In most cases this is part of the command prompt, however, if you are deep down in the folder structure, the command prompt will only display a few parent directories.

\begin{verbatim}
$ pwd
\end{verbatim}

  \{: .language-bash\}

\begin{verbatim}
~/Documents/GitRepos/CEU_MD_Onboard/onboarding/
\end{verbatim}

  \{: .output\}

  Now, we are at the \emph{\textasciitilde/Documents/GitRepos/CEU\_MD\_Onboard/onboarding/} after typing the \texttt{pwd}. (Don't worry about the tilde (``\textasciitilde{}'') sign. You are going to learn about it in a minute.
\item
  \texttt{cd} changes the working directory. It has a positional argument, which is the target directory. The target directory can be either given as an absolute path or a relative path.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#absolute path
  \$ cd /srv/sandbox/

  \#relative path
  \$ cd ../../srv/sandbox/
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  In relative paths you can reference the parent directory by two dots \texttt{..}, thus if you want to go to the parent directory, you should issue \texttt{cd\ ..}. Some more commonly used \texttt{cd} commands:
  \textasciitilde\textasciitilde\textasciitilde{}
  \#Going to your home directory
  \$ cd

  \#going to the root folder
  \$ cd /

  \#going up to the parent directory
  \$ cd ..

  \#going to the Desktop directory in the home directory
  \$ cd \textasciitilde/Desktop
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  The tilde (``\textasciitilde{}'') character in the last command is a shortcut for indicating the home directory.
\item
  \texttt{start} will open a file in the default application associated with it on \textbf{Windows} (aka your default application on Windows).
\item
  \texttt{open} will open a file in the default application associated with it on \textbf{MacOS} (aka your default application on MacOS).
\item
  \texttt{xdg-open} will open a file in the default application associated with it on Ubuntu and many other \textbf{Linux} distributions (aka your default application on any Linux distros).

  The example is opening a picture in the default picture viewer.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#On Windows
  \$ start my-picture.png

  \#On MacOS
  \$ open my-picture.png

  \#On (most) Linux distros
  \$ xdg-open my-picture.png
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\end{itemize}

\hypertarget{file-system-exploration}{%
\section{File System Exploration}\label{file-system-exploration}}

\begin{itemize}
\item
  \texttt{ls} lists the content of the current working directory. It has a wide set of optional arguments that you can combine to get a listing you prefer. A few of these are:

  \begin{itemize}
  \tightlist
  \item
    \texttt{-l} will give you the list of files with one file in one line, and it will include additional information on file permissions, file owners, file size and modification date.
  \item
    \texttt{-a} will list all files and folders including hidden ones.
  \item
    \texttt{-S} will sort the files by size in descending order before listing them.
  \item
    \texttt{-t} will sort the files by modification time (newest first) before listing them.
  \item
    \texttt{-r} will revert the order of files before listing them.
  \item
    \texttt{-h} will display the file sizes in a human-readable format.
  \item
    You can combine these options, so for example \texttt{ls\ -ltrha} will list all files, including hidden ones, in a list where one file will be one line, and the oldest file will be the first (notice the revert option, that is why it's not the newest) and file sizes will be human-readable.
  \end{itemize}

\begin{verbatim}
$ ls -ltrha  
\end{verbatim}

  \{: .language-bash\}
\item
  \texttt{less} will show you the content of a text file. It has one positional argument, the text file. It's worth noting that it can be any text file, for example \texttt{.py} python codes can be viewed as well as \texttt{.csv} data files.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ less trial.py
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  You can scroll up and down using the arrows on your keyboard and exit by pressing \texttt{q}.

  FIXME: Adding a table of useful \texttt{less} associated keyboard combos
\item
  \texttt{file} will determine file type. In fact, one of the common ideas in Unix-like operating systems such as Linux is that ``everything is a file.''

\begin{verbatim}
$ file picture.jpg 
\end{verbatim}

  \{: .language-bash\}

\begin{verbatim}
picture.jpg: JPEG image data, JFIF standard 1.01  
\end{verbatim}

  \{: .output\}
\end{itemize}

\hypertarget{files-and-directories-manipulation}{%
\section{Files and Directories Manipulation}\label{files-and-directories-manipulation}}

\begin{itemize}
\item
  \texttt{cp} copies a file. It has two positional arguments, the source file and the target file.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#Copy a file to the parent folder
  \$ cp my-file.txt ../my-file.txt

  \#Copy a folder to the parent folder by using -R recursive option
  \$ cp -R my-folder/ ../
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\item
  \texttt{mv} moves a file or folder. It has two positional arguments, the source and the target path.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#Move a file to the parent directory
  \$ mv my-file.txt ../

  \#Move the directory ``my-folder'' and its content to the parent directory
  \$ mv my-folder ../
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  It is also the way to rename files.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#``old-filename.txt'' will be renamed to ``new-filename.txt''
  \$ mv old-filename.txt new-filename.txt
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\item
  \texttt{mkdir} creates a new folder in the current working directory. It has a single positional argument, which is the name of the new folder.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ mkdir my-new-folder
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  It can also have multiple optional arguments if you wish to create multiple folders.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ mkdir dir1 dir2 dir3
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  It is even possible to create nested folder structures by providing the \texttt{-p} argument.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ mkdir -p dir4/dir5/dir6
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\item
  \texttt{rmdir} removes an empty directory. It's only positional argument is the folder to be removed. It only removes empty folders, you need to delete it's content first.
\item
  \texttt{rm} removes a file. It has a positional argument, which is a list of files to be removed. You can give multiple files separated by spaces to remove.
  \textasciitilde\textasciitilde\textasciitilde{}
  \#Remove a single file
  \$ rm my-text.txt

  \#Remove multiple files
  \$ rm my-text.txt my-data.dta
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  \textbf{IMPORTANT}: If you remove a file by \texttt{rm} it will be \textbf{permanently} deleted, be careful with it!
\item
  Recursive \texttt{rm} removes a directory with all of its subdirectories and files. It can be accessed with the \texttt{-r} optional argument.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ rm my\_folder/ -r
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  \textbf{IMPORTANT}: Recursive \texttt{rm} will remove the directory with all of it's content \textbf{permanently}.
\item
  Recursive forced \texttt{rm} removes a directory with all of its subfolders and files even if the files are read-only. It can be executed using the \texttt{rf} optional argument.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ rm my\_folder/ -rf
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

  \textbf{IMPORTANT}: deletion is \textbf{permanent}. You should not use it in general, it is only a last resort. The presence of read-only files strongly suggests that they should not be deleted using \texttt{rm}, but in some other ways (e.g.~\texttt{bead\ nuke} in case of beads). There are some cases when this is useful, but use it with care and only if it is unavoidable.
\item
  Some useful shortcuts which could be used with the some of the above-mentioned commands:

  \begin{itemize}
  \tightlist
  \item
    \texttt{?} , a question mark can be used to indicate ``any single character''.
  \item
    \texttt{*}, an asterisk can be used to indicate ``zero or more characters''.
  \end{itemize}

\begin{verbatim}
#Instead of using 
$ cat test_1.txt test_2.txt test_3.txt

#Better usage is
$ cat test_?.txt

#An even shorter solution is
$ cat test_*  
\end{verbatim}

  \{: .language-bash\}

  You are going to learn about \texttt{cat} command in the next section.
\end{itemize}

\hypertarget{redirection-and-some-other-useful-commands}{%
\section{Redirection and some other useful commands}\label{redirection-and-some-other-useful-commands}}

\begin{itemize}
\tightlist
\item
  \texttt{cat} will print the content of files on your terminal screen. It's positional argument is a file list separated by spaces.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ cat my-code.py
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\end{itemize}

If you specify multiple files, it will con\texttt{cat}enate (its name comes from here), meaning that linking together and output each of them, one after the other, as a single block of text as it could be seen at the end of the \textbf{Files and Directories Manipulation} section.

\begin{itemize}
\item
  \texttt{head} and \texttt{tail} shows you the first and last few lines of a text file, respectively. It has one positional argument, the text file.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ head my-data.csv
  \$ tail my-data.csv
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}
\item
  \texttt{echo} will print the value of its argument on your terminal screen.
  \textasciitilde\textasciitilde\textasciitilde{}
  \$ echo hello world!
  \textasciitilde\textasciitilde\textasciitilde{}
  \{: .language-bash\}

\begin{verbatim}
hello world!
\end{verbatim}

  \{: .output\}
\item
  Some, other useful commands and shortcuts:

  \begin{itemize}
  \item
    \texttt{\textgreater{}} redirection operator will redirect standard output to another file instead of the screen. However, using this will \emph{ALWAYS} overwrite the content of that file
  \item
    \texttt{\textgreater{}\textgreater{}} redirection operator will do the same as \texttt{\textgreater{}} does, \textbf{BUT} it will \textbf{not} overwrite the output file. Instead, it will append the content of that file.
  \item
    \texttt{\textbar{}} pipeline operator connects the ouput of one command with the input of a second command.
  \item
    \texttt{sort} will sort lines of text.
  \item
    \texttt{uniq} will report or omit repeated lines.
  \item
    \texttt{wc} will print newline, word, and byte counts for each file. \texttt{wc\ -l} only counts the number of the lines.
  \item
    \texttt{cut} will print selected parts of lines from each file to standard output.
  \item
    \texttt{history} will display previous commands typed in the command line.
  \item
    \texttt{nano} will open the Nano text editor.
  \item
    \texttt{grep} will print lines matching a pattern.
  \end{itemize}

  For more information, please consult the \textbf{Chapter 6 - Redirection} in ``The Linux Command Line'' book.
\end{itemize}

\hypertarget{file-permissions}{%
\section{File Permissions}\label{file-permissions}}

For concise description, please visit the \emph{File Permissions} section of the following link: \textless{}\url{https://datacarpentry.org/shell-economics/03-working-with-files/index.html} /\textgreater{}

\hypertarget{useful-resources-for-learning-terminal}{%
\chapter{Useful resources for learning Terminal:}\label{useful-resources-for-learning-terminal}}

\begin{itemize}
\tightlist
\item
  Introdutction to the Command Line for Economics: \textless{}\url{https://datacarpentry.org/shell-economics} /\textgreater{}
\item
  Official Ubuntu tutorial: \textless{}\url{https://ubuntu.com/tutorials/command-line-for-beginners\#1-overview} /\textgreater{}
\item
  The Linux Command Line by William Shotts: \textless{}\url{http://linuxcommand.org/tlcl.php} /\textgreater{} (freely available)
\end{itemize}

\hypertarget{literature}{%
\chapter{Literature}\label{literature}}

Here is a review of existing methods.

\hypertarget{methods}{%
\chapter{Methods}\label{methods}}

We describe our methods in this chapter.

\hypertarget{applications}{%
\chapter{Applications}\label{applications}}

Some \emph{significant} applications are demonstrated in this chapter.

\hypertarget{example-one}{%
\section{Example one}\label{example-one}}

\hypertarget{example-two}{%
\section{Example two}\label{example-two}}

\hypertarget{final-words}{%
\chapter{Final Words}\label{final-words}}

We have finished a nice book.

  \bibliography{book.bib,packages.bib}

\end{document}
